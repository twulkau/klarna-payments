<?php
/**
 * CreateOrderRequest
 *
 * PHP version 5
 *
 * @category Class
 * @package  Klarna\Payments
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * klarna-payments
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 20200630142900
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.13
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Klarna\Payments\Model;

use \ArrayAccess;
use \Klarna\Payments\ObjectSerializer;

/**
 * CreateOrderRequest Class Doc Comment
 *
 * @category Class
 * @package  Klarna\Payments
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CreateOrderRequest implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'create_order_request';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'acquiring_channel' => 'string',
        'attachment' => '\Klarna\Payments\Model\Attachment',
        'authorization_token' => 'string',
        'auto_capture' => 'bool',
        'billing_address' => '\Klarna\Payments\Model\Address',
        'client_token' => 'string',
        'custom_payment_method_ids' => 'string[]',
        'customer' => '\Klarna\Payments\Model\Customer',
        'design' => 'string',
        'expires_at' => '\Klarna\Payments\Model\Instant',
        'locale' => 'string',
        'merchant_data' => 'string',
        'merchant_reference1' => 'string',
        'merchant_reference2' => 'string',
        'merchant_urls' => '\Klarna\Payments\Model\MerchantUrls',
        'options' => '\Klarna\Payments\Model\Options',
        'order_amount' => 'int',
        'order_lines' => '\Klarna\Payments\Model\OrderLine[]',
        'order_tax_amount' => 'int',
        'payment_method_categories' => '\Klarna\Payments\Model\PaymentMethodCategory[]',
        'purchase_country' => 'string',
        'purchase_currency' => 'string',
        'shipping_address' => '\Klarna\Payments\Model\Address',
        'status' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'acquiring_channel' => null,
        'attachment' => null,
        'authorization_token' => null,
        'auto_capture' => null,
        'billing_address' => null,
        'client_token' => null,
        'custom_payment_method_ids' => null,
        'customer' => null,
        'design' => null,
        'expires_at' => null,
        'locale' => null,
        'merchant_data' => null,
        'merchant_reference1' => null,
        'merchant_reference2' => null,
        'merchant_urls' => null,
        'options' => null,
        'order_amount' => 'int64',
        'order_lines' => null,
        'order_tax_amount' => 'int64',
        'payment_method_categories' => null,
        'purchase_country' => null,
        'purchase_currency' => null,
        'shipping_address' => null,
        'status' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'acquiring_channel' => 'acquiring_channel',
        'attachment' => 'attachment',
        'authorization_token' => 'authorization_token',
        'auto_capture' => 'auto_capture',
        'billing_address' => 'billing_address',
        'client_token' => 'client_token',
        'custom_payment_method_ids' => 'custom_payment_method_ids',
        'customer' => 'customer',
        'design' => 'design',
        'expires_at' => 'expires_at',
        'locale' => 'locale',
        'merchant_data' => 'merchant_data',
        'merchant_reference1' => 'merchant_reference1',
        'merchant_reference2' => 'merchant_reference2',
        'merchant_urls' => 'merchant_urls',
        'options' => 'options',
        'order_amount' => 'order_amount',
        'order_lines' => 'order_lines',
        'order_tax_amount' => 'order_tax_amount',
        'payment_method_categories' => 'payment_method_categories',
        'purchase_country' => 'purchase_country',
        'purchase_currency' => 'purchase_currency',
        'shipping_address' => 'shipping_address',
        'status' => 'status'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'acquiring_channel' => 'setAcquiringChannel',
        'attachment' => 'setAttachment',
        'authorization_token' => 'setAuthorizationToken',
        'auto_capture' => 'setAutoCapture',
        'billing_address' => 'setBillingAddress',
        'client_token' => 'setClientToken',
        'custom_payment_method_ids' => 'setCustomPaymentMethodIds',
        'customer' => 'setCustomer',
        'design' => 'setDesign',
        'expires_at' => 'setExpiresAt',
        'locale' => 'setLocale',
        'merchant_data' => 'setMerchantData',
        'merchant_reference1' => 'setMerchantReference1',
        'merchant_reference2' => 'setMerchantReference2',
        'merchant_urls' => 'setMerchantUrls',
        'options' => 'setOptions',
        'order_amount' => 'setOrderAmount',
        'order_lines' => 'setOrderLines',
        'order_tax_amount' => 'setOrderTaxAmount',
        'payment_method_categories' => 'setPaymentMethodCategories',
        'purchase_country' => 'setPurchaseCountry',
        'purchase_currency' => 'setPurchaseCurrency',
        'shipping_address' => 'setShippingAddress',
        'status' => 'setStatus'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'acquiring_channel' => 'getAcquiringChannel',
        'attachment' => 'getAttachment',
        'authorization_token' => 'getAuthorizationToken',
        'auto_capture' => 'getAutoCapture',
        'billing_address' => 'getBillingAddress',
        'client_token' => 'getClientToken',
        'custom_payment_method_ids' => 'getCustomPaymentMethodIds',
        'customer' => 'getCustomer',
        'design' => 'getDesign',
        'expires_at' => 'getExpiresAt',
        'locale' => 'getLocale',
        'merchant_data' => 'getMerchantData',
        'merchant_reference1' => 'getMerchantReference1',
        'merchant_reference2' => 'getMerchantReference2',
        'merchant_urls' => 'getMerchantUrls',
        'options' => 'getOptions',
        'order_amount' => 'getOrderAmount',
        'order_lines' => 'getOrderLines',
        'order_tax_amount' => 'getOrderTaxAmount',
        'payment_method_categories' => 'getPaymentMethodCategories',
        'purchase_country' => 'getPurchaseCountry',
        'purchase_currency' => 'getPurchaseCurrency',
        'shipping_address' => 'getShippingAddress',
        'status' => 'getStatus'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATUS_COMPLETE = 'complete';
    const STATUS_INCOMPLETE = 'incomplete';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_COMPLETE,
            self::STATUS_INCOMPLETE,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['acquiring_channel'] = isset($data['acquiring_channel']) ? $data['acquiring_channel'] : null;
        $this->container['attachment'] = isset($data['attachment']) ? $data['attachment'] : null;
        $this->container['authorization_token'] = isset($data['authorization_token']) ? $data['authorization_token'] : null;
        $this->container['auto_capture'] = isset($data['auto_capture']) ? $data['auto_capture'] : false;
        $this->container['billing_address'] = isset($data['billing_address']) ? $data['billing_address'] : null;
        $this->container['client_token'] = isset($data['client_token']) ? $data['client_token'] : null;
        $this->container['custom_payment_method_ids'] = isset($data['custom_payment_method_ids']) ? $data['custom_payment_method_ids'] : null;
        $this->container['customer'] = isset($data['customer']) ? $data['customer'] : null;
        $this->container['design'] = isset($data['design']) ? $data['design'] : null;
        $this->container['expires_at'] = isset($data['expires_at']) ? $data['expires_at'] : null;
        $this->container['locale'] = isset($data['locale']) ? $data['locale'] : null;
        $this->container['merchant_data'] = isset($data['merchant_data']) ? $data['merchant_data'] : null;
        $this->container['merchant_reference1'] = isset($data['merchant_reference1']) ? $data['merchant_reference1'] : null;
        $this->container['merchant_reference2'] = isset($data['merchant_reference2']) ? $data['merchant_reference2'] : null;
        $this->container['merchant_urls'] = isset($data['merchant_urls']) ? $data['merchant_urls'] : null;
        $this->container['options'] = isset($data['options']) ? $data['options'] : null;
        $this->container['order_amount'] = isset($data['order_amount']) ? $data['order_amount'] : null;
        $this->container['order_lines'] = isset($data['order_lines']) ? $data['order_lines'] : null;
        $this->container['order_tax_amount'] = isset($data['order_tax_amount']) ? $data['order_tax_amount'] : null;
        $this->container['payment_method_categories'] = isset($data['payment_method_categories']) ? $data['payment_method_categories'] : null;
        $this->container['purchase_country'] = isset($data['purchase_country']) ? $data['purchase_country'] : null;
        $this->container['purchase_currency'] = isset($data['purchase_currency']) ? $data['purchase_currency'] : null;
        $this->container['shipping_address'] = isset($data['shipping_address']) ? $data['shipping_address'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['locale'] === null) {
            $invalidProperties[] = "'locale' can't be null";
        }
        if (!preg_match("/^[A-Za-z]{2,2}(?:-[A-Za-z]{2,2})*$/", $this->container['locale'])) {
            $invalidProperties[] = "invalid value for 'locale', must be conform to the pattern /^[A-Za-z]{2,2}(?:-[A-Za-z]{2,2})*$/.";
        }

        if (!is_null($this->container['merchant_data']) && (mb_strlen($this->container['merchant_data']) > 1024)) {
            $invalidProperties[] = "invalid value for 'merchant_data', the character length must be smaller than or equal to 1024.";
        }

        if (!is_null($this->container['merchant_data']) && (mb_strlen($this->container['merchant_data']) < 0)) {
            $invalidProperties[] = "invalid value for 'merchant_data', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['merchant_reference1']) && (mb_strlen($this->container['merchant_reference1']) > 255)) {
            $invalidProperties[] = "invalid value for 'merchant_reference1', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['merchant_reference1']) && (mb_strlen($this->container['merchant_reference1']) < 0)) {
            $invalidProperties[] = "invalid value for 'merchant_reference1', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['merchant_reference2']) && (mb_strlen($this->container['merchant_reference2']) > 255)) {
            $invalidProperties[] = "invalid value for 'merchant_reference2', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['merchant_reference2']) && (mb_strlen($this->container['merchant_reference2']) < 0)) {
            $invalidProperties[] = "invalid value for 'merchant_reference2', the character length must be bigger than or equal to 0.";
        }

        if ($this->container['order_amount'] === null) {
            $invalidProperties[] = "'order_amount' can't be null";
        }
        if (($this->container['order_amount'] < 0)) {
            $invalidProperties[] = "invalid value for 'order_amount', must be bigger than or equal to 0.";
        }

        if ($this->container['order_lines'] === null) {
            $invalidProperties[] = "'order_lines' can't be null";
        }
        if (!is_null($this->container['order_tax_amount']) && ($this->container['order_tax_amount'] < 0)) {
            $invalidProperties[] = "invalid value for 'order_tax_amount', must be bigger than or equal to 0.";
        }

        if ($this->container['purchase_country'] === null) {
            $invalidProperties[] = "'purchase_country' can't be null";
        }
        if (!preg_match("/^[A-Za-z]{2,2}$/", $this->container['purchase_country'])) {
            $invalidProperties[] = "invalid value for 'purchase_country', must be conform to the pattern /^[A-Za-z]{2,2}$/.";
        }

        if ($this->container['purchase_currency'] === null) {
            $invalidProperties[] = "'purchase_currency' can't be null";
        }
        if (!preg_match("/^[A-Za-z]{3,3}$/", $this->container['purchase_currency'])) {
            $invalidProperties[] = "invalid value for 'purchase_currency', must be conform to the pattern /^[A-Za-z]{3,3}$/.";
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets acquiring_channel
     *
     * @return string
     */
    public function getAcquiringChannel()
    {
        return $this->container['acquiring_channel'];
    }

    /**
     * Sets acquiring_channel
     *
     * @param string $acquiring_channel The acquiring channel in which the session takes place. Ecommerce is default unless specified. Any other values should be defined in the agreement.
     *
     * @return $this
     */
    public function setAcquiringChannel($acquiring_channel)
    {
        $this->container['acquiring_channel'] = $acquiring_channel;

        return $this;
    }

    /**
     * Gets attachment
     *
     * @return \Klarna\Payments\Model\Attachment
     */
    public function getAttachment()
    {
        return $this->container['attachment'];
    }

    /**
     * Sets attachment
     *
     * @param \Klarna\Payments\Model\Attachment $attachment Extra Merchant Data (additional information) required for additional risk check. The required parameters will be described in the appendix of contract agreement.
     *
     * @return $this
     */
    public function setAttachment($attachment)
    {
        $this->container['attachment'] = $attachment;

        return $this;
    }

    /**
     * Gets authorization_token
     *
     * @return string
     */
    public function getAuthorizationToken()
    {
        return $this->container['authorization_token'];
    }

    /**
     * Sets authorization_token
     *
     * @param string $authorization_token Authorization token.
     *
     * @return $this
     */
    public function setAuthorizationToken($authorization_token)
    {
        $this->container['authorization_token'] = $authorization_token;

        return $this;
    }

    /**
     * Gets auto_capture
     *
     * @return bool
     */
    public function getAutoCapture()
    {
        return $this->container['auto_capture'];
    }

    /**
     * Sets auto_capture
     *
     * @param bool $auto_capture Allow merchant to trigger auto capturing.
     *
     * @return $this
     */
    public function setAutoCapture($auto_capture)
    {
        $this->container['auto_capture'] = $auto_capture;

        return $this;
    }

    /**
     * Gets billing_address
     *
     * @return \Klarna\Payments\Model\Address
     */
    public function getBillingAddress()
    {
        return $this->container['billing_address'];
    }

    /**
     * Sets billing_address
     *
     * @param \Klarna\Payments\Model\Address $billing_address Provide the billing address of the customer, if you have collected already. If not, then Klarna will collect the details inside the iFrame before authorization.
     *
     * @return $this
     */
    public function setBillingAddress($billing_address)
    {
        $this->container['billing_address'] = $billing_address;

        return $this;
    }

    /**
     * Gets client_token
     *
     * @return string
     */
    public function getClientToken()
    {
        return $this->container['client_token'];
    }

    /**
     * Sets client_token
     *
     * @param string $client_token Token to be passed to the JS client
     *
     * @return $this
     */
    public function setClientToken($client_token)
    {
        $this->container['client_token'] = $client_token;

        return $this;
    }

    /**
     * Gets custom_payment_method_ids
     *
     * @return string[]
     */
    public function getCustomPaymentMethodIds()
    {
        return $this->container['custom_payment_method_ids'];
    }

    /**
     * Sets custom_payment_method_ids
     *
     * @param string[] $custom_payment_method_ids Promo codes - The array could be used to define which of the configured payment options within a payment category (pay_later, pay_over_time, etc.) should be shown for this purchase. Discuss with the delivery manager to know about the promo codes that will be configured for your account. The feature could also be used to provide promotional offers to specific customers (eg: 0% financing). Please be informed that the usage of this feature can have commercial implications.
     *
     * @return $this
     */
    public function setCustomPaymentMethodIds($custom_payment_method_ids)
    {
        $this->container['custom_payment_method_ids'] = $custom_payment_method_ids;

        return $this;
    }

    /**
     * Gets customer
     *
     * @return \Klarna\Payments\Model\Customer
     */
    public function getCustomer()
    {
        return $this->container['customer'];
    }

    /**
     * Sets customer
     *
     * @param \Klarna\Payments\Model\Customer $customer Object to provide the details of the customer making the payment.
     *
     * @return $this
     */
    public function setCustomer($customer)
    {
        $this->container['customer'] = $customer;

        return $this;
    }

    /**
     * Gets design
     *
     * @return string
     */
    public function getDesign()
    {
        return $this->container['design'];
    }

    /**
     * Sets design
     *
     * @param string $design Design package to use in the session. This can only by used if a custom design has been implemented for Klarna Payments and agreed upon in the agreement. It might have a financial impact. Delivery manager will provide the value for the parameter.
     *
     * @return $this
     */
    public function setDesign($design)
    {
        $this->container['design'] = $design;

        return $this;
    }

    /**
     * Gets expires_at
     *
     * @return \Klarna\Payments\Model\Instant
     */
    public function getExpiresAt()
    {
        return $this->container['expires_at'];
    }

    /**
     * Sets expires_at
     *
     * @param \Klarna\Payments\Model\Instant $expires_at Session expiration date
     *
     * @return $this
     */
    public function setExpiresAt($expires_at)
    {
        $this->container['expires_at'] = $expires_at;

        return $this;
    }

    /**
     * Gets locale
     *
     * @return string
     */
    public function getLocale()
    {
        return $this->container['locale'];
    }

    /**
     * Sets locale
     *
     * @param string $locale Used to define the language and region of the customer. The locale follows the format of RFC 1766, meaning language-country The following values are applicable:  AT: \"de-AT\", \"de-DE\", \"en-DE\" BE: \"be-BE\", \"nl-BE\", \"fr-BE\", \"en-BE\" CH: \"it-CH\", \"de-CH\", \"fr-CH\", \"en-CH\" DE: \"de-DE\", \"de-AT\", \"en-DE\" DK: \"da-DK\", \"en-DK\" ES: \"es-ES\", \"ca-ES\", \"en-ES\" FI: \"fi-FI\", \"sv-FI\", \"en-FI\" GB: \"en-GB\" IT: \"it-IT\", \"en-IT\" NL: \"nl-NL\", \"en-NL\" NO: \"nb-NO\", \"en-NO\" PL: \"pl-PL\", \"en-PL\" SE: \"sv-SE\", \"en-SE\" US: \"en-US\"
     *
     * @return $this
     */
    public function setLocale($locale)
    {

        if ((!preg_match("/^[A-Za-z]{2,2}(?:-[A-Za-z]{2,2})*$/", $locale))) {
            throw new \InvalidArgumentException("invalid value for $locale when calling CreateOrderRequest., must conform to the pattern /^[A-Za-z]{2,2}(?:-[A-Za-z]{2,2})*$/.");
        }

        $this->container['locale'] = $locale;

        return $this;
    }

    /**
     * Gets merchant_data
     *
     * @return string
     */
    public function getMerchantData()
    {
        return $this->container['merchant_data'];
    }

    /**
     * Sets merchant_data
     *
     * @param string $merchant_data Pass through field to send any information about the order to be used later for reference while retrieving the order details (max 1024 characters)
     *
     * @return $this
     */
    public function setMerchantData($merchant_data)
    {
        if (!is_null($merchant_data) && (mb_strlen($merchant_data) > 1024)) {
            throw new \InvalidArgumentException('invalid length for $merchant_data when calling CreateOrderRequest., must be smaller than or equal to 1024.');
        }
        if (!is_null($merchant_data) && (mb_strlen($merchant_data) < 0)) {
            throw new \InvalidArgumentException('invalid length for $merchant_data when calling CreateOrderRequest., must be bigger than or equal to 0.');
        }

        $this->container['merchant_data'] = $merchant_data;

        return $this;
    }

    /**
     * Gets merchant_reference1
     *
     * @return string
     */
    public function getMerchantReference1()
    {
        return $this->container['merchant_reference1'];
    }

    /**
     * Sets merchant_reference1
     *
     * @param string $merchant_reference1 Used for storing merchant's internal order number or other reference. If set, will be shown on the confirmation page as \"order number\" and send to the customer in the confirmation mail after a successful direct bank transfer payment. It will also be included in the payments description in the customer's bank account and settlement files to the merchant (max 255 characters).
     *
     * @return $this
     */
    public function setMerchantReference1($merchant_reference1)
    {
        if (!is_null($merchant_reference1) && (mb_strlen($merchant_reference1) > 255)) {
            throw new \InvalidArgumentException('invalid length for $merchant_reference1 when calling CreateOrderRequest., must be smaller than or equal to 255.');
        }
        if (!is_null($merchant_reference1) && (mb_strlen($merchant_reference1) < 0)) {
            throw new \InvalidArgumentException('invalid length for $merchant_reference1 when calling CreateOrderRequest., must be bigger than or equal to 0.');
        }

        $this->container['merchant_reference1'] = $merchant_reference1;

        return $this;
    }

    /**
     * Gets merchant_reference2
     *
     * @return string
     */
    public function getMerchantReference2()
    {
        return $this->container['merchant_reference2'];
    }

    /**
     * Sets merchant_reference2
     *
     * @param string $merchant_reference2 Used for storing merchant's internal order number or other reference. The value is available in the settlement files. (max 255 characters).
     *
     * @return $this
     */
    public function setMerchantReference2($merchant_reference2)
    {
        if (!is_null($merchant_reference2) && (mb_strlen($merchant_reference2) > 255)) {
            throw new \InvalidArgumentException('invalid length for $merchant_reference2 when calling CreateOrderRequest., must be smaller than or equal to 255.');
        }
        if (!is_null($merchant_reference2) && (mb_strlen($merchant_reference2) < 0)) {
            throw new \InvalidArgumentException('invalid length for $merchant_reference2 when calling CreateOrderRequest., must be bigger than or equal to 0.');
        }

        $this->container['merchant_reference2'] = $merchant_reference2;

        return $this;
    }

    /**
     * Gets merchant_urls
     *
     * @return \Klarna\Payments\Model\MerchantUrls
     */
    public function getMerchantUrls()
    {
        return $this->container['merchant_urls'];
    }

    /**
     * Sets merchant_urls
     *
     * @param \Klarna\Payments\Model\MerchantUrls $merchant_urls Used to send in the different merchant URLs that Klarna needs at different stages of the process.
     *
     * @return $this
     */
    public function setMerchantUrls($merchant_urls)
    {
        $this->container['merchant_urls'] = $merchant_urls;

        return $this;
    }

    /**
     * Gets options
     *
     * @return \Klarna\Payments\Model\Options
     */
    public function getOptions()
    {
        return $this->container['options'];
    }

    /**
     * Sets options
     *
     * @param \Klarna\Payments\Model\Options $options Design customization options for the Klarna Payments iframe. The design options are limited to changing colors. It is not possible to change the font or other designs at the moment.
     *
     * @return $this
     */
    public function setOptions($options)
    {
        $this->container['options'] = $options;

        return $this;
    }

    /**
     * Gets order_amount
     *
     * @return int
     */
    public function getOrderAmount()
    {
        return $this->container['order_amount'];
    }

    /**
     * Sets order_amount
     *
     * @param int $order_amount Total amount of the order including tax and any available discounts. The value should be in non-negative minor units. Eg: 25 Euros should be 2500.
     *
     * @return $this
     */
    public function setOrderAmount($order_amount)
    {

        if (($order_amount < 0)) {
            throw new \InvalidArgumentException('invalid value for $order_amount when calling CreateOrderRequest., must be bigger than or equal to 0.');
        }

        $this->container['order_amount'] = $order_amount;

        return $this;
    }

    /**
     * Gets order_lines
     *
     * @return \Klarna\Payments\Model\OrderLine[]
     */
    public function getOrderLines()
    {
        return $this->container['order_lines'];
    }

    /**
     * Sets order_lines
     *
     * @param \Klarna\Payments\Model\OrderLine[] $order_lines The array containing list of line items that are part of this order. Maximum of 1000 line items could be processed in a single order.
     *
     * @return $this
     */
    public function setOrderLines($order_lines)
    {
        $this->container['order_lines'] = $order_lines;

        return $this;
    }

    /**
     * Gets order_tax_amount
     *
     * @return int
     */
    public function getOrderTaxAmount()
    {
        return $this->container['order_tax_amount'];
    }

    /**
     * Sets order_tax_amount
     *
     * @param int $order_tax_amount Total tax amount of the order. The value should be in non-negative minor units. Eg: 25 Euros should be 2500.
     *
     * @return $this
     */
    public function setOrderTaxAmount($order_tax_amount)
    {

        if (!is_null($order_tax_amount) && ($order_tax_amount < 0)) {
            throw new \InvalidArgumentException('invalid value for $order_tax_amount when calling CreateOrderRequest., must be bigger than or equal to 0.');
        }

        $this->container['order_tax_amount'] = $order_tax_amount;

        return $this;
    }

    /**
     * Gets payment_method_categories
     *
     * @return \Klarna\Payments\Model\PaymentMethodCategory[]
     */
    public function getPaymentMethodCategories()
    {
        return $this->container['payment_method_categories'];
    }

    /**
     * Sets payment_method_categories
     *
     * @param \Klarna\Payments\Model\PaymentMethodCategory[] $payment_method_categories Available payment method categories
     *
     * @return $this
     */
    public function setPaymentMethodCategories($payment_method_categories)
    {
        $this->container['payment_method_categories'] = $payment_method_categories;

        return $this;
    }

    /**
     * Gets purchase_country
     *
     * @return string
     */
    public function getPurchaseCountry()
    {
        return $this->container['purchase_country'];
    }

    /**
     * Sets purchase_country
     *
     * @param string $purchase_country The purchase country of the customer. The billing country always overrides purchase country if the values are different. Formatted according to ISO 3166 alpha-2 standard, e.g. GB, SE, DE, US, etc.
     *
     * @return $this
     */
    public function setPurchaseCountry($purchase_country)
    {

        if ((!preg_match("/^[A-Za-z]{2,2}$/", $purchase_country))) {
            throw new \InvalidArgumentException("invalid value for $purchase_country when calling CreateOrderRequest., must conform to the pattern /^[A-Za-z]{2,2}$/.");
        }

        $this->container['purchase_country'] = $purchase_country;

        return $this;
    }

    /**
     * Gets purchase_currency
     *
     * @return string
     */
    public function getPurchaseCurrency()
    {
        return $this->container['purchase_currency'];
    }

    /**
     * Sets purchase_currency
     *
     * @param string $purchase_currency The purchase currency of the order. Formatted according to ISO 4217 standard, e.g. USD, EUR, SEK, GBP, etc.
     *
     * @return $this
     */
    public function setPurchaseCurrency($purchase_currency)
    {

        if ((!preg_match("/^[A-Za-z]{3,3}$/", $purchase_currency))) {
            throw new \InvalidArgumentException("invalid value for $purchase_currency when calling CreateOrderRequest., must conform to the pattern /^[A-Za-z]{3,3}$/.");
        }

        $this->container['purchase_currency'] = $purchase_currency;

        return $this;
    }

    /**
     * Gets shipping_address
     *
     * @return \Klarna\Payments\Model\Address
     */
    public function getShippingAddress()
    {
        return $this->container['shipping_address'];
    }

    /**
     * Sets shipping_address
     *
     * @param \Klarna\Payments\Model\Address $shipping_address The shipping address of the consumer. Please note that this is not needed unless the customer has explicitly chosen to enter a separate shipping address. Otherwise the billing address will be automatically cloned.
     *
     * @return $this
     */
    public function setShippingAddress($shipping_address)
    {
        $this->container['shipping_address'] = $shipping_address;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status The current status of the session. Possible values: 'complete', 'incomplete' where 'complete' is set when the order has been placed.
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


